package com.alex.webshop.repository;

import android.util.Log;

import com.alex.webshop.model.Customer;
import com.alex.webshop.model.Order;
import com.alex.webshop.model.Product;
import com.alex.webshop.service.ConnectionEnum;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.stream.Collectors;

public class OrderRepo {

    private final ConnectionEnum connectionEnum;
    private final List<Customer> allCustomersList;
    private final List<Product> allProductsList;
    private List<Order> allOrders;

    public OrderRepo(ConnectionEnum connectionEnum, List<Customer> allCustomersList, List<Product> allProductsList) {
        this.connectionEnum = connectionEnum;
        this.allCustomersList = allCustomersList;
        this.allProductsList = allProductsList;
    }

    public List<Order> getAllOrders() {
        allOrders = new ArrayList<>();
        Order tempOrder;

        try (Connection con = DriverManager.getConnection(connectionEnum.getConnString(), connectionEnum.getUser(), connectionEnum.getPass())) {

            // The object used for executing a static SQL statement and returning the results it produces
            Statement statement = con.createStatement();

            // A table of data representing a database result set,
            // which is usually generated by executing a statement that queries the database.
            ResultSet resultSet = statement.executeQuery("SELECT CustomerOrder.id as 'OrderId', Customer.id as 'CustomerId', ProductSize.id as 'ProductSizeId', Product.id as 'ProductId' " +
                    "FROM Customer " +
                    "INNER JOIN CustomerOrder ON CustomerOrder.customerId  = Customer.id " +
                    "INNER JOIN ProductCustomerOrder ON ProductCustomerOrder.customerOrderId = CustomerOrder.id " +
                    "INNER JOIN ProductSize on ProductCustomerOrder.productSizeId = ProductSize.id " +
                    "INNER JOIN Product on Product.id = ProductSize.productId ");


            while (resultSet.next()) {

                tempOrder = new Order();
                tempOrder.setId(resultSet.getInt("OrderId"));
                tempOrder.setCustomer(getCustomerById(resultSet.getInt("CustomerId")));
                // Kommer bara lägga till 1 sen använder vi stream API för att fixa alla produkter korrekt på alla ordrar
                tempOrder.setListOfProducts(List.of(getProductByProductSizeId(resultSet.getInt("ProductSizeId"))));
                allOrders.add(tempOrder);
            }

        } catch (SQLException e) {
            e.printStackTrace();
            Log.d("webshopen", "Error reading orders from db");
        }

        return allOrders;
    }

    private Product getProductByProductSizeId(int productSizeId) {
        return allProductsList.stream()
                .filter(product -> product.getProductSizeId() == productSizeId)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("Doesnt Exist"));
    }

    private Customer getCustomerById(int id) {
        return allCustomersList.stream()
                .filter(e -> e.getId() == id).findFirst()
                .orElseThrow(() -> new NoSuchElementException("Customer does not exist"));
    }

    // TODO OBSOLETE ?
    private boolean checkIfExists(int id) {
        return allOrders.stream().anyMatch(order -> order.getId() == id);
    }

    // TODO OBSOLETE ?
    public List<Product> getProductsBelongingToOrder(int id) {
        return allProductsList.stream()
                .filter(e -> e.getProductSizeId() == id).collect(Collectors.toList());
    }
}
